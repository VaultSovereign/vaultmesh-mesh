// Legacy CLI plumbing has a few benign pedantic hits we’ll resolve incrementally.
// Scope the allows to this file only—core libs remain strict.
#![allow(clippy::similar_names, clippy::uninlined_format_args)]

mod env_meta;
mod identity;
pub mod receipt;
pub mod schema;

use crate::env_meta::collect_env_metadata;
use crate::identity::resolve_actor_did;
use crate::schema::{validate_provenance, validate_receipt as validate_receipt_schema};
use anyhow::{anyhow, Result};
use base64::{engine::general_purpose, Engine as _};
use blake3::Hasher;
use chrono::Utc;
use clap::{Parser, Subcommand, ValueEnum};
use ed25519_dalek::{Keypair, PublicKey, SecretKey, Signature, Signer, Verifier};
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};
use std::io::Write as _;
use std::collections::{BTreeMap, HashMap};
use std::fs;

#[derive(Parser)]
#[command(
    name = "vaultmesh",
    about = "VaultMesh CLI — receipts, Merkle, verification"
)]
struct Cli {
    #[command(subcommand)]
    cmd: Cmd,
}

#[derive(Subcommand)]
enum Cmd {
    /// Receipt operations
    Receipt {
        #[command(subcommand)]
        cmd: ReceiptCmd,
    },
    /// Generate an ed25519 keypair and write JSON
    Keys {
        #[command(subcommand)]
        cmd: KeysCmd,
    },
    /// Compute BLAKE3 hash of a file
    Hash {
        #[command(subcommand)]
        cmd: HashCmd,
    },
    /// Build a daily Merkle root from receipts in a directory
    Seal {
        /// Date (YYYY-MM-DD)
        #[arg(long)]
        date: String,
        /// Directory containing receipts (each a JSON file)
        #[arg(long, default_value = ".")]
        dir: String,
        /// Output path for root JSON
        #[arg(long)]
        out: String,
    },
    /// Anchor a receipt by computing its Merkle path from a directory
    Anchor {
        /// Path to receipt JSON
        #[arg(long)]
        receipt: String,
        /// Directory containing ALL receipts for the date
        #[arg(long)]
        dir: String,
        /// Date (YYYY-MM-DD)
        #[arg(long)]
        date: String,
        /// Output path for anchored receipt
        #[arg(long)]
        out: String,
    },
    /// Sign a finalized receipt with an ed25519 key
    Sign {
        /// Path to receipt JSON (must be finalized)
        #[arg(long)]
        receipt: String,
        /// Path to key JSON generated by `keys generate`
        #[arg(long)]
        key: String,
        /// Output path for signed receipt
        #[arg(long)]
        out: String,
    },
    /// Verify a receipt against a published root
    Verify {
        /// Path to receipt JSON
        #[arg(long)]
        receipt: String,
        /// Path to root JSON
        #[arg(long)]
        root: String,
        /// Perform extra checks (capability present, approvals exist)
        #[arg(long, default_value_t = false)]
        strict: bool,
    },
    /// Glue receipts: identity+env+signature
    Glue {
        #[command(subcommand)]
        cmd: GlueCmd,
    },
    /// Ledger operations (content-addressed store)
    Ledger {
        #[command(subcommand)]
        cmd: LedgerCmd,
    },
    /// Sync operations (placeholder)
    Sync {
        #[command(subcommand)]
        cmd: SyncCmd,
    },
}

#[derive(Subcommand)]
enum KeysCmd {
    /// Generate ed25519 keypair JSON
    Generate {
        /// Output path for key JSON
        #[arg(long)]
        out: String,
    },
}

#[derive(Subcommand)]
enum HashCmd {
    /// Compute BLAKE3 hash of a file (hex)
    File {
        #[arg(long)]
        file: String,
    },
}

#[derive(Subcommand)]
enum GlueCmd {
    /// Emit a minimal receipt for an artifact
    /// Identity precedence: `VM_ACTOR_DID` > (`VM_DID_WEB_DOMAIN` + `VM_OIDC_JWT`) > `VM_ACTOR_KEY_PATH`|~/.vaultmesh/actor.key
    /// Docs: README/OPERATORS.md
    Emit {
        #[arg(long)]
        kind: String,
        /// Path to artifact to hash (BLAKE3)
        #[arg(long)]
        artifact: String,
        /// Path to write provenance JSON (default: provenance.json)
        #[arg(long, default_value = "provenance.json")]
        provenance_out: String,
        /// How to include provenance: embed|refer|braid (default: refer)
        #[arg(long = "provenance", value_enum, default_value_t = ProvenanceMode::Refer)]
        provenance_mode: ProvenanceMode,
    },
    /// Verify a glue receipt + optional OPA policy
    /// Requires `opa` in PATH when policy is provided
    Verify {
        /// Path to receipt JSON
        #[arg(long)]
        receipt: String,
        /// Path to policy file (rego)
        #[arg(long, default_value = "policy/guard.rego")]
        policy: String,
        /// Action context for policy (e.g., plan/apply)
        #[arg(long, default_value = "plan")]
        action: String,
    },
}

#[derive(Subcommand)]
enum LedgerCmd {
    /// Add one or more JSON files to the local ledger (~/.vaultmesh/ledger)
    Add {
        /// Files to add (receipt/provenance JSON)
        #[arg(required = true)]
        files: Vec<String>,
    },
    /// List entries in the local ledger
    Ls,
}

#[derive(Subcommand)]
enum SyncCmd {
    /// Placeholder: pulls from URL (pending verification)
    Pull { url: String },
}

#[derive(Copy, Clone, Eq, PartialEq, Debug, ValueEnum)]
enum ProvenanceMode {
    Embed,
    Refer,
    Braid,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
struct Receipt {
    id: String,
    ts: String,
    actor: Actor,
    op: Op,
    build: Build,
    env: Env,
    sign: Sign,
    leaf: String,
    merkle: Merkle,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
struct Actor {
    id: String,
    cap: Vec<String>,
    sig: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default)]
struct Op {
    kind: String,
    target: String,
    #[serde(default)]
    risk: Option<String>,
    #[serde(default)]
    change_window: Option<String>,
    #[serde(default)]
    approvals: Vec<String>,
    plan_hash: String,
    apply_hash: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
struct Build {
    repo: String,
    commit: String,
    binary_hash: String,
}

#[derive(Serialize, Deserialize, Clone, Debug, Default)]
struct Env {
    #[serde(default)]
    ci: Option<String>,
    #[serde(default)]
    runner: Option<String>,
    #[serde(default)]
    tf_version: Option<String>,
    #[serde(default)]
    plugins: Option<Vec<String>>,
    #[serde(default, skip_serializing_if = "BTreeMap::is_empty")]
    entries: BTreeMap<String, String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
struct Sign {
    alg: String,
    #[serde(rename = "sig")]
    signature: String,
    #[serde(rename = "pub")]
    public_key: String,
}
impl Sign {
    fn none() -> Self {
        Self {
            alg: "none".into(),
            signature: String::new(),
            public_key: String::new(),
        }
    }
}

#[derive(Serialize, Deserialize, Clone, Debug, Default)]
struct Merkle {
    date: String,
    path: Vec<String>,
    root: String,
}

#[derive(Subcommand)]
enum ReceiptCmd {
    /// Emit a pre-apply receipt from a Terraform plan JSON
    Emit {
        #[arg(long)]
        kind: String,
        #[arg(long)]
        target: String,
        #[arg(long)]
        plan: String,
        #[arg(long)]
        cap: String,
        /// Accept multiple --approve flags and comma-delimited lists (alice,bob)
        #[arg(long, value_delimiter = ',', action = clap::ArgAction::Append)]
        approve: Vec<String>,
        #[arg(long)]
        repo: String,
        #[arg(long)]
        commit: String,
        #[arg(long, default_value = "dev-binary")]
        binary_hash: String,
        #[arg(long)]
        out: String,
    },
    /// Finalize a receipt with post-apply JSON
    Finalize {
        #[arg(long)]
        receipt: String,
        #[arg(long)]
        post: String,
        #[arg(long)]
        out: String,
    },
}

// ---------- Utility ----------
fn read(path: &str) -> Result<Vec<u8>> {
    Ok(fs::read(path)?)
}
fn write(path: &str, s: &str) -> Result<()> {
    Ok(fs::write(path, s)?)
}
fn blake3_hex(bytes: &[u8]) -> String {
    let mut h = Hasher::new();
    h.update(bytes);
    hex::encode(h.finalize().as_bytes())
}

fn hex_concat_ordered(a_hex: &str, b_hex: &str) -> Vec<u8> {
    let (a, b) = if a_hex <= b_hex {
        (a_hex, b_hex)
    } else {
        (b_hex, a_hex)
    };
    let mut bytes = Vec::with_capacity(a.len() / 2 + b.len() / 2);
    bytes.extend(hex::decode(a).expect("hex decode a"));
    bytes.extend(hex::decode(b).expect("hex decode b"));
    bytes
}

fn to_value<T: Serialize>(t: &T) -> Value {
    serde_json::to_value(t).expect("serialize")
}

fn remove_leaf_and_merkle(mut v: Value) -> Value {
    if let Value::Object(ref mut m) = v {
        m.remove("leaf");
        m.remove("merkle");
    }
    v
}

fn remove_leaf_merkle_and_sig(mut v: Value) -> Value {
    if let Value::Object(ref mut m) = v {
        m.remove("leaf");
        m.remove("merkle");
        if let Some(Value::Object(ref mut s)) = m.get_mut("sign") {
            s.remove("sig");
        }
    }
    v
}

fn sort_json(v: Value) -> Value {
    match v {
        Value::Object(map) => {
            let mut b = BTreeMap::new();
            for (k, val) in map {
                b.insert(k, sort_json(val));
            }
            Value::Object(b.into_iter().collect())
        }
        Value::Array(arr) => Value::Array(arr.into_iter().map(sort_json).collect()),
        _ => v,
    }
}

fn canonical_payload_json_v2<T: Serialize>(t: &T) -> String {
    let v = to_value(t);
    let v = remove_leaf_merkle_and_sig(v);
    let v = sort_json(v);
    serde_json::to_string(&v).unwrap()
}

fn canonical_payload_json_legacy<T: Serialize>(t: &T) -> String {
    let v = to_value(t);
    let v = remove_leaf_and_merkle(v);
    let v = sort_json(v);
    serde_json::to_string(&v).unwrap()
}

fn canonical_leaf_hex<T: Serialize>(t: &T) -> String {
    blake3_hex(canonical_payload_json_v2(t).as_bytes())
}

fn canonical_leaf_hex_legacy<T: Serialize>(t: &T) -> String {
    blake3_hex(canonical_payload_json_legacy(t).as_bytes())
}

fn blake3_file_hex(p: &std::path::Path) -> Result<String> {
    use std::io::Read;
    let mut f = std::fs::File::open(p)?;
    let mut hasher = blake3::Hasher::new();
    let mut buf = [0u8; 8192];
    loop {
        let n = f.read(&mut buf)?;
        if n == 0 {
            break;
        }
        hasher.update(&buf[..n]);
    }
    Ok(hex::encode(hasher.finalize().as_bytes()))
}

// ---------- Merkle ----------
fn build_merkle(leaves: &[String]) -> (String, HashMap<String, Vec<String>>) {
    if leaves.is_empty() {
        return (String::new(), HashMap::new());
    }
    let mut layer = leaves.to_vec();
    let mut paths: HashMap<String, Vec<String>> = HashMap::new();

    // Initialize paths map
    for l in &layer {
        paths.entry(l.clone()).or_default();
    }

    let mut next_layer;
    while layer.len() > 1 {
        next_layer = Vec::new();
        for chunk in layer.chunks(2) {
            let (left, right) = if chunk.len() == 2 {
                (chunk[0].clone(), chunk[1].clone())
            } else {
                (chunk[0].clone(), chunk[0].clone()) // duplicate odd leaf
            };
            let parent_hex = blake3_hex(&hex_concat_ordered(&left, &right));
            // record sibling for paths
            paths.entry(left.clone()).or_default().push(right.clone());
            paths.entry(right.clone()).or_default().push(left.clone());
            next_layer.push(parent_hex);
        }
        layer = next_layer;
    }
    (layer[0].clone(), paths)
}

fn fold_path_to_root(leaf: &str, path: &[String]) -> String {
    let mut cur = leaf.to_string();
    for sib in path {
        cur = blake3_hex(&hex_concat_ordered(&cur, sib));
    }
    cur
}

// ---------- Main ----------
#[allow(clippy::too_many_lines)]
fn main() -> Result<()> {
    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or("info")).init();
    let cli = Cli::parse();
    match cli.cmd {
        Cmd::Receipt { cmd } => match cmd {
            ReceiptCmd::Emit {
                kind,
                target,
                plan,
                cap,
                approve,
                repo,
                commit,
                binary_hash,
                out,
            } => {
                let plan_hash = blake3_hex(&read(&plan)?);
                let id = ulid::Ulid::new().to_string();
                let ts = Utc::now().to_rfc3339_opts(chrono::SecondsFormat::Secs, true);

                // Validate and normalize approvals
                let approvals: Vec<String> = approve
                    .into_iter()
                    .map(|s| s.trim().to_string())
                    .filter(|s| !s.is_empty())
                    .collect();
                if approvals.is_empty() {
                    return Err(anyhow!("receipt emit: at least one approval is required"));
                }
                if approvals.len() < 2 {
                    eprintln!(
                        "⚠️  Warning: strict mode verification requires ≥2 approvals (have {})",
                        approvals.len()
                    );
                }

                // Resolve actor DID dynamically
                let actor_did = resolve_actor_did().unwrap_or_else(|e| {
                    eprintln!("⚠️  Warning: failed to resolve actor DID: {}", e);
                    "did:placeholder".to_string()
                });

                // Collect CI/CD environment metadata
                let env_meta = collect_env_metadata();
                let tf_version = env_meta.entries.get("terraform_version").cloned();

                let env = Env {
                    ci: env_meta.ci,
                    runner: env_meta.runner,
                    tf_version,
                    plugins: None,
                    entries: env_meta.entries,
                };

                let mut rec = Receipt {
                    id,
                    ts,
                    actor: Actor {
                        id: actor_did,
                        cap: vec![cap],
                        sig: String::new(),
                    },
                    op: Op {
                        kind,
                        target,
                        risk: None,
                        change_window: None,
                        approvals,
                        plan_hash,
                        apply_hash: String::new(),
                    },
                    build: Build {
                        repo,
                        commit,
                        binary_hash,
                    },
                    env,
                    sign: Sign::none(),
                    leaf: String::new(),
                    merkle: Merkle {
                        date: String::new(),
                        path: vec![],
                        root: String::new(),
                    },
                };
                rec.leaf = canonical_leaf_hex(&rec);
                write(&out, &serde_json::to_string_pretty(&rec)?)?;
                println!("EMITTED {}", out);
            }
            ReceiptCmd::Finalize { receipt, post, out } => {
                let mut rec: Receipt = serde_json::from_slice(&read(&receipt)?)?;
                rec.op.apply_hash = blake3_hex(&read(&post)?);
                rec.leaf = canonical_leaf_hex(&rec);
                write(&out, &serde_json::to_string_pretty(&rec)?)?;
                println!("FINALIZED {}", out);
            }
        },
        Cmd::Keys { cmd } => match cmd {
            KeysCmd::Generate { out } => {
                // generate from OS randomness without full rand crate
                let mut seed = [0u8; 32];
                getrandom::getrandom(&mut seed).map_err(|e| anyhow!("getrandom error: {}", e))?;
                let secret =
                    SecretKey::from_bytes(&seed).map_err(|e| anyhow!("secret key error: {}", e))?;
                let public = PublicKey::from(&secret);
                let kp = Keypair { secret, public };
                let key_json = json!({
                    "alg": "ed25519",
                    "public": general_purpose::STANDARD.encode(kp.public.as_bytes()),
                    "secret": general_purpose::STANDARD.encode(kp.secret.as_bytes()),
                });
                write(&out, &serde_json::to_string_pretty(&key_json)?)?;
                println!("KEY WRITTEN {}", out);
            }
        },
        Cmd::Hash { cmd } => match cmd {
            HashCmd::File { file } => {
                let bytes = read(&file)?;
                println!("{}", blake3_hex(&bytes));
            }
        },
        Cmd::Seal { date, dir, out } => {
            let mut leaves: Vec<String> = Vec::new();
            for entry in fs::read_dir(&dir)? {
                let p = entry?.path();
                if p.extension().and_then(|s| s.to_str()) == Some("json") {
                    let rec: Receipt = serde_json::from_slice(&fs::read(&p)?)?;
                    leaves.push(rec.leaf.clone());
                }
            }
            leaves.sort(); // deterministic
            let (root, _paths) = build_merkle(&leaves);
            let root_doc = json!({
                "date": date,
                "root": root,
                "count": leaves.len()
            });
            write(&out, &serde_json::to_string_pretty(&root_doc)?)?;
            println!("SEALED {}", out);
        }
        Cmd::Anchor {
            receipt,
            dir,
            date,
            out,
        } => {
            // Build tree to compute path for the given receipt
            let rec_bytes = read(&receipt)?;
            let mut rec: Receipt = serde_json::from_slice(&rec_bytes)?;
            let mut leaves: Vec<String> = Vec::new();
            for entry in fs::read_dir(&dir)? {
                let p = entry?.path();
                if p.extension().and_then(|s| s.to_str()) == Some("json") {
                    let r: Receipt = serde_json::from_slice(&fs::read(&p)?)?;
                    leaves.push(r.leaf.clone());
                }
            }
            leaves.sort();
            let (root, paths) = build_merkle(&leaves);
            let path = paths
                .get(&rec.leaf)
                .ok_or_else(|| anyhow!("leaf not found in set; ensure dir is the correct date"))?;
            rec.merkle = Merkle {
                date,
                path: path.clone(),
                root,
            };
            write(&out, &serde_json::to_string_pretty(&rec)?)?;
            println!("ANCHORED {}", out);
        }
        Cmd::Sign { receipt, key, out } => {
            #[derive(Deserialize)]
            struct KeyJson {
                alg: String,
                public: String,
                secret: String,
            }
            let kj: KeyJson = serde_json::from_slice(&read(&key)?)?;
            if kj.alg.to_lowercase() != "ed25519" {
                return Err(anyhow!("unsupported key alg: {}", kj.alg));
            }
            let pub_bytes = general_purpose::STANDARD
                .decode(kj.public.as_bytes())
                .map_err(|e| anyhow!("invalid public key b64: {}", e))?;
            let sec_bytes = general_purpose::STANDARD
                .decode(kj.secret.as_bytes())
                .map_err(|e| anyhow!("invalid secret key b64: {}", e))?;
            let public =
                PublicKey::from_bytes(&pub_bytes).map_err(|e| anyhow!("bad public: {}", e))?;
            let secret =
                SecretKey::from_bytes(&sec_bytes).map_err(|e| anyhow!("bad secret: {}", e))?;
            let kp = Keypair { secret, public };

            let mut rec: Receipt = serde_json::from_slice(&read(&receipt)?)?;
            // populate signing metadata before canonicalizing
            rec.sign = Sign {
                alg: "ed25519".into(),
                signature: String::new(),
                public_key: general_purpose::STANDARD.encode(kp.public.as_bytes()),
            };
            let msg = canonical_payload_json_v2(&rec);
            let sig: Signature = kp.sign(msg.as_bytes());
            rec.sign.signature = general_purpose::STANDARD.encode(sig.to_bytes());
            // ensure leaf reflects signed payload
            rec.leaf = canonical_leaf_hex(&rec);
            write(&out, &serde_json::to_string_pretty(&rec)?)?;
            println!("SIGNED {}", out);
        }
        Cmd::Verify {
            receipt,
            root,
            strict,
        } => {
            let rec: Receipt = serde_json::from_slice(&read(&receipt)?)?;
            let computed_leaf = canonical_leaf_hex(&rec);
            let mut legacy_ok = false;
            if computed_leaf != rec.leaf {
                let legacy_leaf = canonical_leaf_hex_legacy(&rec);
                if legacy_leaf == rec.leaf {
                    legacy_ok = true;
                    eprintln!("warning: legacy leaf accepted (included sign.sig)");
                } else {
                    return Err(anyhow!("leaf mismatch: receipt tampered or not canonical"));
                }
            }
            let root_doc: Value = serde_json::from_slice(&read(&root)?)?;
            let root_hex = root_doc
                .get("root")
                .and_then(|v| v.as_str())
                .ok_or_else(|| anyhow!("invalid root.json"))?;
            let folded = fold_path_to_root(&rec.leaf, &rec.merkle.path);
            if folded != root_hex {
                return Err(anyhow!("path->root mismatch"));
            }
            if strict {
                if rec.actor.cap.is_empty() {
                    return Err(anyhow!("strict: missing capability"));
                }
                if rec.op.approvals.len() < 2 {
                    return Err(anyhow!("strict: need >=2 approvals"));
                }
                if rec.op.plan_hash.is_empty() || rec.op.apply_hash.is_empty() {
                    return Err(anyhow!("strict: missing plan/apply hashes"));
                }
                // Require ed25519 signature
                if rec.sign.alg.to_lowercase() != "ed25519"
                    || rec.sign.signature.is_empty()
                    || rec.sign.public_key.is_empty()
                {
                    return Err(anyhow!("strict: missing ed25519 signature"));
                }
                let pub_bytes = general_purpose::STANDARD
                    .decode(rec.sign.public_key.as_bytes())
                    .map_err(|e| anyhow!("strict: bad public b64: {}", e))?;
                let sig_bytes = general_purpose::STANDARD
                    .decode(rec.sign.signature.as_bytes())
                    .map_err(|e| anyhow!("strict: bad signature b64: {}", e))?;
                let pk = PublicKey::from_bytes(&pub_bytes)
                    .map_err(|e| anyhow!("strict: bad public: {}", e))?;
                let sig = Signature::from_bytes(&sig_bytes)
                    .map_err(|e| anyhow!("strict: bad signature: {}", e))?;
                let msg = if legacy_ok {
                    canonical_payload_json_legacy(&rec)
                } else {
                    canonical_payload_json_v2(&rec)
                };
                pk.verify(msg.as_bytes(), &sig)
                    .map_err(|_| anyhow!("strict: signature verification failed"))?;
            }
            println!("VERIFIED ✅");
        }
        Cmd::Glue { cmd } => match cmd {
            GlueCmd::Emit {
                kind,
                artifact,
                provenance_out,
                provenance_mode,
            } => {
                // load actor keypair
                let kp = identity::load_actor_keypair()?;
                // subject digest
                let digest = blake3_file_hex(std::path::Path::new(&artifact))?;
                let subject = receipt::Subject {
                    kind,
                    digest: digest.clone(),
                    meta: None,
                };
                let r_base = receipt::build_receipt(subject)?;
                let prov = receipt::build_provenance(
                    std::path::Path::new(&artifact),
                    &digest,
                    &r_base.actor,
                    &r_base.env,
                );
                // Schema validate provenance before writing
                validate_provenance(&serde_json::to_value(&prov)?)?;
                std::fs::write(&provenance_out, serde_json::to_vec_pretty(&prov)?)?;

                match provenance_mode {
                    ProvenanceMode::Embed => {
                        let mut r = r_base;
                        r.provenance = Some(prov);
                        // Schema validate receipt prior to signing
                        validate_receipt_schema(&serde_json::to_value(&r)?)?;
                        let signed = receipt::sign_receipt(r, &kp)?;
                        println!("{}", serde_json::to_string_pretty(&signed)?);
                    }
                    ProvenanceMode::Refer | ProvenanceMode::Braid => {
                        let prov_bytes = receipt::canonical_json_bytes(&prov);
                        let prov_hex = receipt::blake3_hex(&prov_bytes);
                        let mut r = r_base;
                        r.provenance_ref = Some(receipt::ProvenanceRef {
                            path: provenance_out.clone(),
                            digest: prov_hex,
                        });
                        validate_receipt_schema(&serde_json::to_value(&r)?)?;
                        let signed = receipt::sign_receipt(r, &kp)?;
                        let json_signed = serde_json::to_string_pretty(&signed)?;
                        println!("{}", json_signed);
                        if matches!(provenance_mode, ProvenanceMode::Braid) {
                            let rcpt_hex = receipt::blake3_hex(json_signed.as_bytes());
                            // rewrite provenance with receipt_digest included
                            let mut prov_val = serde_json::to_value(prov)?;
                            if let serde_json::Value::Object(ref mut m) = prov_val {
                                m.insert(
                                    "receipt_digest".into(),
                                    serde_json::Value::String(rcpt_hex),
                                );
                            }
                            validate_provenance(&prov_val)?;
                            std::fs::write(&provenance_out, serde_json::to_vec_pretty(&prov_val)?)?;
                        }
                    }
                }
            }
            GlueCmd::Verify {
                receipt,
                policy,
                action,
            } => {
                let data: serde_json::Value = serde_json::from_slice(&read(&receipt)?)?;
                // Schema validate incoming receipt JSON
                validate_receipt_schema(&data)?;
                let r: receipt::Receipt = serde_json::from_value(data.clone())?;
                receipt::verify_receipt(&r)?;
                // Run OPA if available
                let mut input = data;
                if let serde_json::Value::Object(ref mut m) = input {
                    m.insert("action".into(), serde_json::Value::String(action));
                }
                let mut child = std::process::Command::new("opa")
                    .args([
                        "eval",
                        "-f",
                        "pretty",
                        "-I",
                        "-i",
                        "-",
                        "-d",
                        &policy,
                        "data.vaultmesh.guard",
                    ])
                    .stdin(std::process::Stdio::piped())
                    .stdout(std::process::Stdio::inherit())
                    .stderr(std::process::Stdio::inherit())
                    .spawn()
                    .map_err(|e| anyhow!("failed to spawn opa: {e}"))?;
                child
                    .stdin
                    .as_mut()
                    .ok_or_else(|| anyhow!("opa stdin unavailable"))?
                    .write_all(serde_json::to_string(&input)?.as_bytes())?;
                let status = child.wait()?;
                if !status.success() {
                    return Err(anyhow!("policy evaluation failed"));
                }
                println!("OPA ✅");
            }
        },
        Cmd::Ledger { cmd } => match cmd {
            LedgerCmd::Add { files } => {
                let home = dirs::home_dir().ok_or_else(|| anyhow!("no home dir"))?;
                let dir = home.join(".vaultmesh").join("ledger");
                std::fs::create_dir_all(&dir)?;
                for f in files {
                    let bytes = read(&f)?;
                    // try parse to decide receipt/provenance and validate
                    if let Ok(v) = serde_json::from_slice::<serde_json::Value>(&bytes) {
                        let ok = validate_receipt_schema(&v).is_ok() || validate_provenance(&v).is_ok();
                        if !ok {
                            return Err(anyhow!("{}: not a valid receipt/provenance", f));
                        }
                    }
                    let digest = blake3_hex(&bytes);
                    let path = dir.join(format!("{digest}.json"));
                    std::fs::write(&path, &bytes)?;
                    println!("{}  {}", digest, f);
                }
            }
            LedgerCmd::Ls => {
                let home = dirs::home_dir().ok_or_else(|| anyhow!("no home dir"))?;
                let dir = home.join(".vaultmesh").join("ledger");
                if !dir.exists() {
                    return Ok(());
                }
                let mut entries: Vec<_> = std::fs::read_dir(&dir)?.collect::<Result<_, _>>()?;
                entries.sort_by_key(std::fs::DirEntry::file_name);
                for e in entries {
                    let name = e.file_name().to_string_lossy().to_string();
                    println!("{}", name);
                }
            }
        },
        Cmd::Sync { cmd } => match cmd {
            SyncCmd::Pull { url } => {
                println!("sync pull {} → pending verification", url);
            }
        },
    }
    Ok(())
}
